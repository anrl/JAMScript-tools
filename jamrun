#!/bin/bash

# Edit the following locations to provide the
MOSQUITTO=`which mosquitto`
if [ -z $MOSQUITTO ]; then
    MOSQUITTO=/usr/local/sbin/mosquitto
fi
MOSQUITTO_PUB=`which mosquitto_pub`
if [ -z $MOSQUITTO_PUB ]; then
    MOSQUITTO_PUB=/usr/local/bin/mosquitto_pub
fi
TMUX=`which tmux`
if [ -z $TMUX ]; then
    die "Warning tmux not found"
fi

# No need to edit below this line unless you find a bug!
## Some functions used in this script


die() {
    printf '%s\n' "$1" >&2
    exit 1
}

show_usage() {
    cat << EOF
jamrun program.jxe
Runs J and C node, one each, of a device with program.jxe
under a default application name 'app-N'. To run under a different
app name X, use the --app=X option.

jamrun program.jxe --fog
Runs a fog node (only J node) with program.jxe. Similarly, the --cloud
flag runs a cloud node.

By default, jamrun uses a Redis server running at 127.0.0.1:6379 as the
data store. The Redis server needs to be started before launching the
application. To use a different Redis server use the --data option.

jamrun program.jxe --data=127.0.0.1:7000
Runs program.jxe and connects it to an already running Redis server at
port 7000 of the local host. Redis server can run outside the
local host (Redis needs to the configured to accept outside
connections).

To start more than one C node at a device use the following command.
jamrun program.jxe --num=4

To provide a set of tags to the program, use the following command.
jamrun program.jxe --tag="param1, param2"

Use the --bg option to run a command in the backgroud.

Usage: jamrun file.jxe [--app=appl_name] [--fog|--cloud] [--num=num_c_devs]
                                    [--data=data-url]
                                    [--tags=quoted_list_of_tags]
                                    [--bg]


The jamrun command creates a run state in the $HOME/__jamrun folder.
EOF
}

checkmosquitto() {

    # Check the required commands..
    if [ ! -e $MOSQUITTO ]; then
        die "Mosquitto MQTT broker $MOSQUITTO not found. Set new location."
    fi
    if [ ! -e $MOSQUITTO_PUB ]; then
        die "Mosquitto tools $MOSQUITTO_PUB not found. Set new location."
    fi
    if [ ! -e $TMUX ]; then
        die "terminal multiplexor $TMUX not found. Set new location."
    fi
}

startmqtt() {
    local port=$1

    # Check whether the MQTT server is running.. if not start it
    $MOSQUITTO_PUB -p $port -t "test" -m "hello"
    if [ $? -ne 0 ]; then
        echo "MQTT is not running at $port"
        echo "Attempting to start MQTT at $port"
        $MOSQUITTO -p $port &
    fi
}

dojamout() {
    local type=$1
    local pnum=$2
    local floc=$3

    startmqtt $pnum
    echo $data > $floc/$pnum/dataStore
    echo "process" > $floc/$pnum/class

    case $type in
        cloud)
            if [ -z "$tags" ]; then
                node jamout.js --app=$jappid --cloud --port=$pnum --data=$data &
                jpid=$!
            else
                node jamout.js --app=$jappid --cloud --port=$pnum --data=$data --tags=$tags &
                jpid=$!
            fi
            ;;
        fog)
            if [ -z "$tags" ]; then
                node jamout.js --app=$jappid --fog --port=$pnum --data=$data &
                jpid=$!
            else
                node jamout.js --app=$jappid --fog --port=$pnum --data=$data --tags=$tags &
                jpid=$!
            fi
            ;;
        device)
            if [ -z "$tags" ]; then
                node jamout.js --app=$jappid --port=$pnum --data=$data &
                jpid=$!
            else
                node jamout.js --app=$jappid --port=$pnum --data=$data --tags=$tags &
                jpid=$!
            fi
            ;;
    esac
}

doaout() {
    local counter=1
    local indx=0
    local num=$1
    local port=$2

    if [ -e a.out ]; then
        chmod +x a.out
    fi
    while [ $counter -le $num ]; do
        if [ -e a.out ]; then
            # execute the program.. we are in the folder..
            $TMUX send-keys -t $tmuxapp:0.$indx "./a.out -a $jappid -p $port -n $counter" C-m
        fi
        ((counter++))
        ((indx++))
    done
}

# This is always scanning for a command with 'node'
portavailable() {
    local folder=$1
    local port=$2

    if [ -d $folder/$port ]; then
        if [ -e $folder/$port/processId ]; then
            local pid=`cat $folder/$port/processId`
            if [ ! -z $pid ]; then
                porttaken=`ps -p $pid | grep node | wc -l`
            else
                porttaken=0
            fi
        else
            porttaken=0
        fi
    else
        porttaken=0
    fi

}


setuptmux() {
    tmuxapp="tg-"$1
    echo $tmuxapp > $dirpath/tmuxid

    if [ "$type" == "device" ]; then
        $TMUX new -s $tmuxapp -d
        counter=1
        while [ $counter -le $num ]; do
            $TMUX split-window -v -t $tmuxapp
            $TMUX select-layout -t $tmuxapp tiled
            ((counter++))
        done
    fi
}

createdir() {
    local jpath=$1
    local jdir=$2
    # set a global directory..
    dirpath=$jpath/$jdir

    if [ ! -e $jpath/$jdir ]; then
        mkdir $jpath/$jdir
    fi
}

getappid() {
    local mainf=$1
    local localf=$2
    local appid=$3

    if [ -e $mainf/counter ]; then
        local count=`cat $mainf/counter`
        ((count++))
        echo $count > $mainf/counter
    else
        local count=1
        echo $count > $mainf/counter
    fi

    if [[ $appid == app-* ]]; then
        if [ ! -e $localf/appid ]; then
            echo "app-"$count > $localf/appid
        fi
    else
        echo $appid > $localf/appid
    fi

    jappid=`cat $localf/appid`
}


cleanuptmux() {
    if [ ! -z $tmuxapp ]; then
        $TMUX kill-session -t $tmuxapp
    fi
    exit
}


waitforcmd() {

    if [ -z $bg ]; then
        trap cleanuptmux SIGINT
        wait $jpid
    fi
}

startredis() {
    local port=$1

    redis-server --port $port &
}

waitforredis() {
    local port=$1

    while : ; do
        local present=`ps ax | grep redis-server | grep $port | wc -l`
        if [ $present == "1" ]; then
            break
        fi
        sleep 1
    done
}


configureredis() {
    local port=$1

    redis-cli -p $port CONFIG SET protected-mode no
}


resolvedocker() {
    local name=$1

    local host="${name%:*}"
    local port="${name##*:}"

    startredis $port
    waitforredis $port

    if [ $host == "docker" ]; then
        local ipaddr=`hostname -I`
        name=$ipaddr:$port

        configureredis $port
    fi
    data=$name
}


# Initialize all the option variables.
app=app-n
type=device
data=127.0.0.1:6379
num=1
tags=
bg=
porttaken=0

file=$1
shift
fext="${file##*.}"

if [ -z $file ] || [ $file = "-h" ] || [ $file = "--help" ]; then
    show_usage
    exit 1
fi

if [ "$fext" != "jxe" ]; then
    die "Extension on $file is not .jxe"
fi


while :; do
    case $1 in
        -h|-\?|--help)
            show_usage      # Display a usage synopsis.
            exit
            ;;
        -a|--app)           # Takes an option argument; ensure it has been specified.
            if [ "$2" ]; then
                app=$2
                shift
            else
                die 'ERROR: "--app" requires a non-empty option argument.'
            fi
            ;;
        --app=?*)
            app=${1#*=}     # Delete everything up to "=" and assign the remainder.
            ;;
        --app=)            # Handle the case of an empty
            die 'ERROR: "--args" requires a non-empty option argument.'
            ;;
        -s|--tags)           # Takes an option argument; ensure it has been specified.
            if [ "$2" ]; then
                tags=$2
                shift
            else
                die 'ERROR: "--tags" requires a non-empty option argument.'
            fi
            ;;
        --tags=?*)
            tags=${1#*=}     # Delete everything up to "=" and assign the remainder.
            ;;
        --tags=)            # Handle the case of an empty
            die 'ERROR: "--tags" requires a non-empty option argument.'
            ;;
        -n|--num)           # Takes an option argument; ensure it has been specified.
            if [ "$2" ]; then
                num=$2
                shift
            else
                die 'ERROR: "--num" requires a non-empty option argument.'
            fi
            ;;
        --num=?*)
            num=${1#*=}     # Delete everything up to "=" and assign the remainder.
            ;;
        --num=)            # Handle the case of an empty
            die 'ERROR: "--num" requires a non-empty option argument.'
            ;;
        -d|--data)           # Takes an option argument; ensure it has been specified.
            if [ "$2" ]; then
                data=$2
                shift
            else
                die 'ERROR: "--data" requires a non-empty option argument.'
            fi
            ;;
        --data=?*)
            data=${1#*=}     # Delete everything up to "=" and assign the remainder.
            ;;
        --data=)            # Handle the case of an empty
            die 'ERROR: "--data" requires a non-empty option argument.'
            ;;
        -f|--fog)
            if [ "$type" != "device" ]; then
                die 'ERROR: "type" cannot be reassigned.'
            else
                type="fog"
                num=
            fi
            ;;
        -c|--cloud)
            if [ "$type" != "device" ]; then
                die 'ERROR: "type" cannot be reassigned.'
            else
                type="cloud"
                num=
            fi
            ;;
        -b|--bg)
            bg=1
            ;;
        --)              # End of all options.
            shift
            break
        ;;
        -?*)
            printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
            ;;
        *)               # Default case: No more options, so break out of the loop.
            break
    esac

    shift
done

# Check necessary parameters and set defaults

if [ "$type" != "device" ] && [ -n "$num" ]; then
    die "number of devices can't be speciied for fog/cloud"
fi

# Check whether mosquitto tools are there
checkmosquitto

if [ -e "$file" ]; then

    # Check whether the global __jamruns folder is there
    jamfolder=$HOME"/__jamruns"
    if [ ! -d $jamfolder ]; then
        mkdir $jamfolder
    fi
    # Get the folder
    filenoext="${file%.*}"
    folder=$HOME"/__jamruns/"$filenoext"_"$app
    if [ ! -d "$folder" ]; then
        mkdir $folder
    fi

    # unzip the executable in the folder and run it..
    # We are unzipping the copying the files no matter what!
    unzip -oq $file -d $folder
    if [ $? -ne 0 ]; then
        die "Problem reading file: $file"
    fi

    cd $folder

    resolvedocker $data

    if [ -e jamout.js ]; then
        # execute the program.. we are in the folder..

        case $type in
            cloud)
                iport=9883
                while [ : ]; do
                    portavailable $folder $iport
                    [[ $porttaken == 1 ]] || break
                    ((iport++))
                done
                getappid $jamfolder $folder $app
                createdir $folder $iport
                dojamout $type $iport $folder
                waitforcmd
            ;;
            fog)
                iport=5883
                while [ : ]; do
                    portavailable $folder $iport
                    [[ $porttaken == 1 ]] || break
                    ((iport++))
                done
                getappid $jamfolder $folder $app
                createdir $folder $iport
                dojamout $type $iport $folder
                waitforcmd
            ;;
            device)
                iport=1883
                while [ : ]; do
                    portavailable $folder $iport
                    if [ $porttaken == 0 ]; then
                        break
                    fi
                    ((iport++))
                done
                getappid $jamfolder $folder $app
                createdir $folder $iport
                dojamout $type $iport $folder
                setuptmux $jpid
                doaout $num $iport
                waitforcmd
            ;;
        esac
    else
        die "File: $file is not a valid JAMScript executable"
    fi

else
    die "File: $file not found"
fi
